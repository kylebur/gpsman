<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GPS Pac-Man (Maze Version)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: #fff; font-family: sans-serif; display: flex; justify-content: center; align-items: center; }
        canvas { display: block; background-color: #000; }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none; /* Allow clicks/taps to pass through to canvas if needed */
        }
        #status, #score {
            background-color: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            color: #lime;
            pointer-events: auto; /* Enable interaction for buttons inside */
        }
         #score { color: #yellow; }
         #controls {
             /* Positioned via flexbox in #ui-container */
             background-color: rgba(0,0,0,0.7);
             padding: 5px;
             border-radius: 5px;
             pointer-events: auto;
         }
         #controls button {
             margin-left: 5px;
             padding: 8px;
             font-size: 10px;
         }
         #warning {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            background-color: rgba(255,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            color: #fff;
         }
         #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: red;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 30px;
            font-weight: bold;
            text-align: center;
            display: none; /* Hidden by default */
         }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="ui-container">
        <div id="status">Requesting GPS permission...</div>
        <div id="controls">
            <button id="recenterBtn">Recenter View</button>
        </div>
         <div id="score">Score: 0</div>
    </div>

    <div id="warning">WARNING: Pay attention to your real-world surroundings while playing!</div>
    <div id="game-over">GAME OVER!</div>

    <script>
        // --- Configuration ---
        const GAME_AREA_WIDTH_FEET = 50;
        const GAME_AREA_HEIGHT_FEET = 50;
        const FEET_TO_METERS = 0.3048;
        const GAME_AREA_WIDTH_METERS = GAME_AREA_WIDTH_FEET * FEET_TO_METERS;
        const GAME_AREA_HEIGHT_METERS = GAME_AREA_HEIGHT_FEET * FEET_TO_METERS;

        // Maze Grid Configuration
        const MAZE_COLS = 15; // Adjust for complexity
        const MAZE_ROWS = 15;
        const TILE_SIZE_METERS_X = GAME_AREA_WIDTH_METERS / MAZE_COLS;
        const TILE_SIZE_METERS_Y = GAME_AREA_HEIGHT_METERS / MAZE_ROWS;

        const PACMAN_SIZE_FACTOR = 0.7; // Fraction of tile size
        const GHOST_SIZE_FACTOR = 0.65;
        const PELLET_SIZE_FACTOR = 0.15;

        const GHOST_SPEED_TILES_PER_SEC = 0.6; // Speed in tiles per second
        const NUM_GHOSTS = 4;
        const GPS_OPTIONS = { enableHighAccuracy: true, maximumAge: 3000, timeout: 10000 };

        // Maze definition (0 = Wall, 1 = Path, 2 = Pellet)
        // Simple symmetrical example - replace with a proper maze generator for more fun
        const maze = [
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,2,2,2,2,2,2,0,2,2,2,2,2,2,0],
            [0,2,0,0,2,0,2,0,2,0,2,0,0,2,0],
            [0,2,0,0,2,2,2,2,2,2,2,0,0,2,0],
            [0,2,2,2,0,0,2,0,2,0,0,2,2,2,0],
            [0,0,0,2,0,2,2,2,2,2,0,2,0,0,0],
            [0,2,2,2,2,2,0,0,0,2,2,2,2,2,0],
            [0,2,0,0,0,2,0,1,0,2,0,0,0,2,0], // Original center path (row 7) - now unused for start
            [0,2,2,2,2,2,0,0,0,2,2,2,2,2,0], // Row 8
            [0,0,0,2,0,2,2,2,2,2,0,2,0,0,0], // Row 9 - PacMan starts here at [9][7] (value 2)
            [0,2,2,2,0,0,2,0,2,0,0,2,2,2,0],
            [0,2,0,0,2,2,2,2,2,2,2,0,0,2,0],
            [0,2,0,0,2,0,2,0,2,0,2,0,0,2,0],
            [0,2,2,2,2,2,2,0,2,2,2,2,2,2,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        ];
        let totalPellets = 0;
        maze.forEach(row => row.forEach(cell => { if (cell === 2) totalPellets++; }));


        // --- Global Variables ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statusElement = document.getElementById('status');
        const scoreElement = document.getElementById('score');
        const recenterBtn = document.getElementById('recenterBtn');
        const gameOverElement = document.getElementById('game-over');

        let canvasWidth, canvasHeight, tileSizePixels; // Set in resize handler

        let initialLat = null, initialLon = null;
        let currentLat = null, currentLon = null;

        // --- FIXED START POSITION ---
        // Start Pac-Man at a known valid path location (approx center X, moved down 2 rows from center Y)
        let pacmanGridX = Math.floor(MAZE_COLS / 2); // Center X = 7
        let pacmanGridY = Math.floor(MAZE_ROWS / 2) + 2; // Center Y (7) + 2 = 9

        // Player's real-world position relative to start (meters) - used for TARGETING moves
        let realWorldX_meters = 0;
        let realWorldY_meters = 0;

        // View offset in PIXELS - centers the view on Pac-Man
        let viewOffsetX = 0;
        let viewOffsetY = 0;

        let ghosts = []; // { x: gridX, y: gridY, targetX: gridX, targetY: gridY, progress: 0, color: 'red' }
        let score = 0;
        let isGameOver = false;
        let gameStarted = false;
        let lastTimestamp = 0;
        let mouthAngle = 0;
        let mouthOpening = true;

        // --- Helper Functions ---
        function degreesToRadians(degrees) { return degrees * Math.PI / 180; }
        function calculateDistance(lat1, lon1, lat2, lon2) { const R = 6371e3; const phi1 = degreesToRadians(lat1); const phi2 = degreesToRadians(lat2); const deltaPhi = degreesToRadians(lat2 - lat1); const deltaLambda = degreesToRadians(lon2 - lon1); const a = Math.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) + Math.cos(phi1) * Math.cos(phi2) * Math.sin(deltaLambda / 2) * Math.sin(deltaLambda / 2); const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return R * c; }
        function calculateDisplacement(startLat, startLon, currentLat, currentLon) { const N_S_dist = calculateDistance(startLat, startLon, currentLat, startLon); const E_W_dist = calculateDistance(startLat, startLon, startLat, currentLon); const deltaY_meters = (currentLat > startLat) ? N_S_dist : -N_S_dist; const deltaX_meters = (currentLon > startLon) ? E_W_dist : -E_W_dist; return { x: deltaX_meters, y: deltaY_meters }; }

        function isWall(gridX, gridY) {
            if (gridX < 0 || gridX >= MAZE_COLS || gridY < 0 || gridY >= MAZE_ROWS) {
                return true; // Out of bounds is a wall
            }
            // Check the maze array for a wall (value 0)
            return maze[gridY][gridX] === 0;
        }

        // Convert Grid coordinates to center Canvas coordinates (including view offset)
        function gridToCanvas(gridX, gridY) {
            // Calculate the center position of the grid cell in pixels
            const canvasX = gridX * tileSizePixels + tileSizePixels / 2;
            const canvasY = gridY * tileSizePixels + tileSizePixels / 2;
            // Return the position relative to the current view offset
            return { x: canvasX, y: canvasY };
        }

         // Convert Real World Meters (relative to start) to Grid coordinates
         function metersToGrid(metersX, metersY) {
            // Calculate grid index based on meter position within the game area
            // Add half the game area width/height to shift origin from center to top-left for calculation
            // Divide by tile size in meters to get grid index
            // Invert Y axis because meters increase upwards, grid Y increases downwards
            const gridX = Math.floor((metersX + GAME_AREA_WIDTH_METERS / 2) / TILE_SIZE_METERS_X);
            const gridY = Math.floor((-metersY + GAME_AREA_HEIGHT_METERS / 2) / TILE_SIZE_METERS_Y);
            // Clamp coordinates to be within the maze boundaries
            return {
                 gridX: Math.max(0, Math.min(MAZE_COLS - 1, gridX)),
                 gridY: Math.max(0, Math.min(MAZE_ROWS - 1, gridY))
            };
         }

        function drawPacman(canvasX, canvasY, radius) {
            // Animate mouth opening and closing
            const baseAngle = Math.PI / 7; // Maximum mouth opening angle
            if (mouthOpening) {
                mouthAngle += 0.08; // Speed of opening
                if (mouthAngle >= baseAngle) mouthOpening = false; // Switch direction
            } else {
                mouthAngle -= 0.08; // Speed of closing
                if (mouthAngle <= 0) mouthOpening = true; // Switch direction
            }

            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            // Draw Pac-Man as an arc, leaving a gap for the mouth
            ctx.arc(canvasX, canvasY, radius, mouthAngle, Math.PI * 2 - mouthAngle);
            // Draw a line to the center to close the shape (like a pie slice missing)
            ctx.lineTo(canvasX, canvasY);
            ctx.closePath();
            ctx.fill();
        }

        function drawGhost(canvasX, canvasY, radius, color) {
            const feet = radius * 0.4; // Height of the wavy feet
            ctx.fillStyle = color;
            ctx.beginPath();
            // Draw the semi-circular head
            ctx.arc(canvasX, canvasY, radius, Math.PI, 0);
            // Draw the bottom edge and wavy feet
            ctx.lineTo(canvasX + radius, canvasY + radius); // Bottom right corner
            // Draw wavy feet using line segments
            ctx.lineTo(canvasX + radius * 0.66, canvasY + radius - feet);
            ctx.lineTo(canvasX + radius * 0.33, canvasY + radius);
            ctx.lineTo(canvasX, canvasY + radius - feet);
            ctx.lineTo(canvasX - radius * 0.33, canvasY + radius);
            ctx.lineTo(canvasX - radius * 0.66, canvasY + radius - feet);
            ctx.lineTo(canvasX - radius, canvasY + radius); // Bottom left corner
            ctx.closePath(); // Close the shape back to the start of the arc
            ctx.fill();

            // Draw Eyes
            ctx.fillStyle = 'white'; // White part of the eyes
            ctx.beginPath();
            // Left eye white
            ctx.arc(canvasX - radius * 0.4, canvasY - radius * 0.2, radius * 0.25, 0, Math.PI * 2);
            // Right eye white
            ctx.arc(canvasX + radius * 0.4, canvasY - radius * 0.2, radius * 0.25, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'black'; // Black pupils
            ctx.beginPath();
            // Left pupil
            ctx.arc(canvasX - radius * 0.4, canvasY - radius * 0.2, radius * 0.1, 0, Math.PI * 2);
             // Right pupil
            ctx.arc(canvasX + radius * 0.4, canvasY - radius * 0.2, radius * 0.1, 0, Math.PI * 2);
            ctx.fill();
        }

        function initGhosts() {
             const ghostColors = ['red', 'pink', 'cyan', 'orange'];
             // Define specific valid starting tiles for ghosts, spread out
             const startingPositions = [
                {x: 1, y: 1}, // Top Left
                {x: MAZE_COLS-2, y: 1}, // Top Right
                {x: 1, y: MAZE_ROWS-2}, // Bottom Left
                {x: MAZE_COLS-2, y: MAZE_ROWS-2} // Bottom Right
             ];
             ghosts = []; // Clear existing ghosts
             for (let i = 0; i < NUM_GHOSTS; i++) {
                 let startX = startingPositions[i % startingPositions.length].x;
                 let startY = startingPositions[i % startingPositions.length].y;

                 // Double-check if the chosen start tile is valid, fallback if not
                 let attempts = 0;
                 while(isWall(startX, startY) && attempts < MAZE_COLS * MAZE_ROWS) {
                     // Simple fallback: try moving right, then down row by row
                     startX++;
                     if (startX >= MAZE_COLS) {
                         startX = 1;
                         startY++;
                         if (startY >= MAZE_ROWS) startY = 1; // Wrap around Y
                     }
                     attempts++;
                 }
                 // If still stuck after many attempts, log an error
                 if (isWall(startX, startY)) {
                     console.error(`Could not find valid starting tile for ghost ${i}`);
                     startX = 1; startY = 1; // Default to top-left corner as last resort
                 }

                 ghosts.push({
                    x: startX, // Current grid X
                    y: startY, // Current grid Y
                    targetX: startX, // Target grid X (initially same as current)
                    targetY: startY, // Target grid Y (initially same as current)
                    progress: 0, // Progress moving towards target (0 to 1)
                    color: ghostColors[i % ghostColors.length] // Assign color
                 });
             }
        }

         function updateGhosts(deltaTime) {
            // Calculate how much progress a ghost makes towards its target tile in this frame
            const moveAmount = GHOST_SPEED_TILES_PER_SEC * deltaTime;

            ghosts.forEach(ghost => {
                 // Increase progress towards the target tile
                 ghost.progress += moveAmount;

                 // If ghost has reached or passed its target tile
                 if (ghost.progress >= 1) {
                     // Snap ghost to the target tile
                     ghost.x = ghost.targetX;
                     ghost.y = ghost.targetY;
                     ghost.progress = 0; // Reset progress for the next move

                     // --- Ghost AI: Decide next move ---
                     const dx = pacmanGridX - ghost.x; // Difference in X grid coords to Pac-Man
                     const dy = pacmanGridY - ghost.y; // Difference in Y grid coords to Pac-Man

                     let possibleMoves = [];
                     // Check potential moves (Up, Down, Left, Right) and if they are valid paths
                     if (!isWall(ghost.x, ghost.y - 1)) possibleMoves.push({ x: 0, y: -1, weight: -dy }); // Up (prefer if PacMan is above)
                     if (!isWall(ghost.x, ghost.y + 1)) possibleMoves.push({ x: 0, y: 1, weight: dy });  // Down (prefer if PacMan is below)
                     if (!isWall(ghost.x - 1, ghost.y)) possibleMoves.push({ x: -1, y: 0, weight: -dx });// Left (prefer if PacMan is left)
                     if (!isWall(ghost.x + 1, ghost.y)) possibleMoves.push({ x: 1, y: 0, weight: dx }); // Right (prefer if PacMan is right)

                     // Basic AI: Prefer moves that reduce distance to Pac-Man (higher weight)
                     possibleMoves.sort((a, b) => b.weight - a.weight);

                     let bestMove = { x: 0, y: 0 }; // Default: stay put if no valid moves
                     if (possibleMoves.length > 0) {
                         // Choose the best valid direction towards Pac-Man
                         bestMove = possibleMoves[0];
                         // Add randomness: Occasionally choose the second-best move if available
                         if (possibleMoves.length > 1 && Math.random() < 0.2) { // 20% chance to pick 2nd best
                             bestMove = possibleMoves[1];
                         }
                     }

                     // Set the next target tile based on the chosen move
                     ghost.targetX = ghost.x + bestMove.x;
                     ghost.targetY = ghost.y + bestMove.y;
                 }
             });
         }


         function checkCollisions() {
             // Pac-Man vs Ghosts Collision Check
             ghosts.forEach(ghost => {
                 // Check if Pac-Man occupies the same grid cell as the ghost's current or target cell
                 // This provides a slightly more lenient collision detection
                 if ((pacmanGridX === ghost.x && pacmanGridY === ghost.y) ||
                     (pacmanGridX === ghost.targetX && pacmanGridY === ghost.targetY))
                 {
                     isGameOver = true; // Set game over flag
                     gameOverElement.textContent = "GAME OVER!"; // Set message
                     gameOverElement.style.color = "red"; // Set color
                     gameOverElement.style.display = 'block'; // Show game over message
                 }
             });

             // Pac-Man vs Pellets Collision Check
             // Check if Pac-Man's current grid cell contains a pellet
             if (maze[pacmanGridY][pacmanGridX] === 2) {
                 maze[pacmanGridY][pacmanGridX] = 1; // Change pellet tile to empty path tile
                 score++; // Increment score
                 totalPellets--; // Decrement remaining pellet count
                 scoreElement.textContent = `Score: ${score}`; // Update score display

                 // Check for win condition (all pellets eaten)
                 if (totalPellets <= 0) {
                    isGameOver = true; // Set game over flag (for winning)
                    gameOverElement.textContent = "YOU WIN!"; // Set win message
                    gameOverElement.style.color = "yellow"; // Set win color
                    gameOverElement.style.display = 'block'; // Show win message
                 }
             }
         }

        // --- GPS Handling ---
        function handleInitialPosition(position) {
            initialLat = position.coords.latitude;
            initialLon = position.coords.longitude;
            currentLat = initialLat;
            currentLon = initialLon;
            statusElement.textContent = "GPS Locked! Walk to move.";
            console.log("Initial Position:", initialLat, initialLon);

            // Check if the explicitly set start position is valid (should be (7,9) which is maze[9][7]=2)
             if (isWall(pacmanGridX, pacmanGridY)) {
                console.error(`FATAL: Explicit start position (${pacmanGridX}, ${pacmanGridY}) is a wall! Check maze definition.`);
                statusElement.textContent = "Error: Invalid start position in maze!";
                statusElement.style.color = "red";
                isGameOver = true; // Prevent game from starting if spawn is bad
                return; // Stop initialization
            }

            initGhosts(); // Initialize ghosts after confirming valid Pac-Man start
            gameStarted = true;
            lastTimestamp = performance.now();
            resizeCanvas(); // Recalculate sizes after start potentially affects tileSizePixels
            gameLoop(); // Start the main game loop

            // Start watching for continuous GPS updates
            navigator.geolocation.watchPosition(handlePositionUpdate, handleError, GPS_OPTIONS);
            // Add listener for the recenter button
            recenterBtn.addEventListener('click', recenterView);
        }

        function handlePositionUpdate(position) {
            // Ignore updates if game hasn't started, is over, or initial position isn't set
            if (!initialLat || isGameOver || !gameStarted) return;

            // Update current latitude and longitude from GPS data
            currentLat = position.coords.latitude;
            currentLon = position.coords.longitude;
            const accuracy = position.coords.accuracy; // GPS accuracy in meters

            // Calculate real-world displacement (in meters) from the starting GPS point
            const displacement = calculateDisplacement(initialLat, initialLon, currentLat, currentLon);
            realWorldX_meters = displacement.x;
            realWorldY_meters = displacement.y;

             // Determine the TARGET grid cell based on the real-world meter position
            const { gridX: targetGridX, gridY: targetGridY } = metersToGrid(realWorldX_meters, realWorldY_meters);

            // Calculate the difference between the target grid cell and Pac-Man's current grid cell
            const deltaGridX = targetGridX - pacmanGridX;
            const deltaGridY = targetGridY - pacmanGridY;

            // Determine the single intended move direction (horizontal or vertical) based on the larger displacement
            let intendedMoveX = 0;
            let intendedMoveY = 0;

            if (Math.abs(deltaGridX) > Math.abs(deltaGridY)) {
                // If horizontal displacement is greater, intend to move horizontally
                intendedMoveX = Math.sign(deltaGridX);
            } else if (Math.abs(deltaGridY) > 0) {
                 // If vertical displacement is greater (or equal and non-zero), intend to move vertically
                intendedMoveY = Math.sign(deltaGridY);
            } else if (Math.abs(deltaGridX) > 0) {
                 // If vertical displacement is zero, but horizontal is non-zero, intend to move horizontally
                 intendedMoveX = Math.sign(deltaGridX);
            }
            // If both deltaGridX and deltaGridY are 0, no intended move (intendedMoveX/Y remain 0)

            // --- Attempt to move Pac-Man based on intended direction ---
            // Try the primary intended direction first
            if (intendedMoveX !== 0 && !isWall(pacmanGridX + intendedMoveX, pacmanGridY)) {
                // If intending to move horizontally and the way is clear, move horizontally
                pacmanGridX += intendedMoveX;
            } else if (intendedMoveY !== 0 && !isWall(pacmanGridX, pacmanGridY + intendedMoveY)) {
                 // If intending to move vertically (and horizontal wasn't possible/intended) and the way is clear, move vertically
                pacmanGridY += intendedMoveY;
            }
            // Allow correcting for diagonal GPS drift if the primary direction was blocked:
            // If primary horizontal move was blocked, but vertical move was also intended (diagonal GPS input) and is possible
            else if (intendedMoveX !== 0 && intendedMoveY !== 0 && !isWall(pacmanGridX, pacmanGridY + intendedMoveY)) {
                 pacmanGridY += intendedMoveY;
            }
            // If primary vertical move was blocked, but horizontal move was also intended (diagonal GPS input) and is possible
            else if (intendedMoveY !== 0 && intendedMoveX !== 0 && !isWall(pacmanGridX + intendedMoveX, pacmanGridY)) {
                 pacmanGridX += intendedMoveX;
            }
            // If no move is possible or intended, Pac-Man stays in the current grid cell (pacmanGridX/Y are unchanged)

            updateStatus(accuracy); // Update the status display with GPS accuracy
        }

        function handleError(error) {
            console.error("GPS Error:", error);
            let message = "GPS Error: ";
            switch (error.code) {
                case error.PERMISSION_DENIED: message += "Permission denied."; break;
                case error.POSITION_UNAVAILABLE: message += "Location unavailable."; break;
                case error.TIMEOUT: message += "Timeout."; break;
                default: message += "Unknown error."; break;
            }
            statusElement.textContent = message;
            statusElement.style.color = 'red';
            isGameOver = true; // Stop the game if GPS fails critically
            gameOverElement.textContent = "GPS FAILED!"; // Display error message
            gameOverElement.style.display = 'block';
        }

        function updateStatus(accuracy = null) {
            if (isGameOver) return; // Don't update status if game is over
            if (!gameStarted) {
                 statusElement.textContent = "Waiting for GPS...";
                 return;
            }
            // Display GPS accuracy if available
            let statusText = `GPS Acc: ${accuracy?.toFixed(1) ?? '?'}m`;
            // Optional: Display grid coordinates for debugging
            // statusText += ` | Grid: ${pacmanGridX},${pacmanGridY}`;
            statusElement.textContent = statusText;
            statusElement.style.color = '#lime'; // Green color for normal status
        }


        // --- Drawing ---
        function drawMaze() {
            const wallColor = '#0000AA'; // Dark Blue for walls
            const pathColor = '#000';   // Black for empty paths (matches background)
            const pelletColor = '#FFFF88'; // Yellowish for pellets

            // Iterate over each cell in the maze grid
            for (let y = 0; y < MAZE_ROWS; y++) {
                for (let x = 0; x < MAZE_COLS; x++) {
                    // Get the canvas coordinates for the center of the current grid cell
                    const { x: canvasX, y: canvasY } = gridToCanvas(x, y);
                     // Calculate the top-left corner coordinates for drawing the tile rectangle
                    const tileDrawX = canvasX - tileSizePixels / 2;
                    const tileDrawY = canvasY - tileSizePixels / 2;

                    // Check the type of tile in the maze definition
                    if (maze[y][x] === 0) { // Wall tile
                        ctx.fillStyle = wallColor;
                        ctx.fillRect(tileDrawX, tileDrawY, tileSizePixels, tileSizePixels);
                    } else { // Path tile (either empty or with a pellet)
                        // Draw the path background (black) first
                        ctx.fillStyle = pathColor;
                        ctx.fillRect(tileDrawX, tileDrawY, tileSizePixels, tileSizePixels);
                        // If it's a pellet tile (value 2), draw the pellet on top
                        if (maze[y][x] === 2) {
                            ctx.fillStyle = pelletColor;
                            ctx.beginPath();
                            // Draw the pellet as a small circle in the center of the tile
                            ctx.arc(canvasX, canvasY, tileSizePixels * PELLET_SIZE_FACTOR, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }
        }

        function recenterView() {
             // This function doesn't need to do much now, as the view offset
             // calculation in draw() automatically tries to center Pac-Man.
             // We can just provide feedback to the user.
             statusElement.textContent = "View adjusted";
             // Reset status message after a short delay
             setTimeout(() => updateStatus(), 2000);
        }

        // --- Game Loop ---
        function update(deltaTime) {
            // Only update game state if the game is running
            if (isGameOver || !gameStarted) return;
            // Update ghost positions and AI
            updateGhosts(deltaTime);
            // Check for collisions between Pac-Man and ghosts/pellets
            checkCollisions();
        }

        function draw() {
            // --- Calculate View Offset ---
            // Get the ideal canvas position where Pac-Man should be drawn
            const { x: pacmanCanvasCenterX, y: pacmanCanvasCenterY } = gridToCanvas(pacmanGridX, pacmanGridY);
            // Calculate the desired offset to center Pac-Man on the screen
            // This is the difference between Pac-Man's position and the screen center
            const targetOffsetX = pacmanCanvasCenterX - canvasWidth / 2;
            const targetOffsetY = pacmanCanvasCenterY - canvasHeight / 2;
            // Smoothly interpolate the current view offset towards the target offset
            // This creates a smooth camera follow effect
            viewOffsetX += (targetOffsetX - viewOffsetX) * 0.1; // Adjust 0.1 for different follow speeds
            viewOffsetY += (targetOffsetY - viewOffsetY) * 0.1;

            // --- Clear Canvas ---
            // Clear the entire canvas with the background color
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // --- Draw Initializing Message ---
            // If the game hasn't started yet (waiting for GPS) and isn't game over
            if (!gameStarted && !isGameOver) {
                ctx.fillStyle = 'white'; ctx.font = '20px sans-serif'; ctx.textAlign = 'center';
                // Display a message indicating the game is waiting for GPS lock
                ctx.fillText('Waiting for GPS Lock...', canvasWidth / 2, canvasHeight / 2);
                return; // Stop drawing further elements until game starts
            }

            // --- Draw Game World Elements (relative to view offset) ---
            ctx.save(); // Save the current canvas state (transformation matrix)
            // Apply the view offset transformation: translate the canvas so the world appears shifted
            ctx.translate(-viewOffsetX, -viewOffsetY);

            // Draw the maze (walls, paths, pellets)
            drawMaze();

            // Draw Ghosts (interpolating position for smooth movement between tiles)
            const ghostRadius = tileSizePixels * GHOST_SIZE_FACTOR / 2;
            ghosts.forEach(ghost => {
                // Get canvas coordinates for the ghost's current and target tiles
                const { x: startX, y: startY } = gridToCanvas(ghost.x, ghost.y);
                const { x: endX, y: endY } = gridToCanvas(ghost.targetX, ghost.targetY);
                // Calculate the interpolated position based on the ghost's progress towards the target
                const currentX = startX + (endX - startX) * ghost.progress;
                const currentY = startY + (endY - startY) * ghost.progress;
                // Draw the ghost at the interpolated position
                drawGhost(currentX, currentY, ghostRadius, ghost.color);
            });

            // Draw Pac-Man at his current grid position's center
            // Note: We use gridToCanvas which inherently includes the view offset calculation done earlier
            const { x: finalPacmanX, y: finalPacmanY } = gridToCanvas(pacmanGridX, pacmanGridY);
            const pacmanRadius = tileSizePixels * PACMAN_SIZE_FACTOR / 2;
            drawPacman(finalPacmanX, finalPacmanY, pacmanRadius);

            ctx.restore(); // Restore the canvas state (remove the view offset transformation)

            // UI elements (Score, Status, Game Over message) are handled by HTML elements, not drawn on canvas here.
        }

        function gameLoop(timestamp) {
             // Initialize lastTimestamp on the first frame
             if (!lastTimestamp) lastTimestamp = timestamp;
             // Calculate delta time (time elapsed since the last frame) in seconds
             // Handle potential NaN on the very first frame by defaulting to 0
             const deltaTime = (timestamp - lastTimestamp) / 1000 || 0;
             lastTimestamp = timestamp; // Update lastTimestamp for the next frame

             // Update game logic only if the game has started and is not over
             if (gameStarted && !isGameOver) {
                 update(deltaTime);
             }
             // Draw the game state (always draw, even if game over, to show the final state/message)
             draw();

             // Request the next animation frame, creating the loop
             requestAnimationFrame(gameLoop);
        }

        // --- Initialization and Resize ---
        function resizeCanvas() {
            // Get current window dimensions
            canvasWidth = window.innerWidth;
            canvasHeight = window.innerHeight;
            // Set canvas element size
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // Calculate the size of each maze tile in pixels to fit the maze on screen
            // Fit based on the dimension that is more constrained
            const pixelWidthPerTile = canvasWidth / MAZE_COLS;
            const pixelHeightPerTile = canvasHeight / MAZE_ROWS;
            // Use the smaller dimension to ensure the entire maze fits without stretching tiles
            tileSizePixels = Math.min(pixelWidthPerTile, pixelHeightPerTile);

            // No need to redraw immediately, the game loop handles drawing continuously
        }

        window.onload = () => {
            // Display initial safety warning
            alert("SAFETY WARNING:\nPlease be constantly aware of your real-world surroundings while playing!");
            // Set initial canvas size
            resizeCanvas();
            // Add event listener to resize canvas when window size changes
            window.addEventListener('resize', resizeCanvas);

            // Check if Geolocation API is available in the browser
            if ('geolocation' in navigator) {
                // Request the initial GPS position
                navigator.geolocation.getCurrentPosition(handleInitialPosition, handleError, GPS_OPTIONS);
            } else {
                // Geolocation not supported, display error and stop game
                statusElement.textContent = 'Geolocation not supported!'; statusElement.style.color = 'red';
                isGameOver = true;
                gameOverElement.textContent = "GPS NOT SUPPORTED!";
                gameOverElement.style.display = 'block';
            }
        };

    </script>
</body>
</html>
