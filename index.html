<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GPS Pac-Man</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: #fff; font-family: sans-serif; }
        canvas { display: block; }
        #status {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            color: #lime;
         }
         #warning {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            background-color: rgba(255,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            color: #fff;
         }
         #controls {
             position: absolute;
             top: 50px;
             left: 10px;
             background-color: rgba(0,0,0,0.7);
             padding: 5px 10px;
             border-radius: 5px;
         }
         #controls button {
             margin: 5px;
             padding: 8px;
         }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="status">Requesting GPS permission...</div>
    <div id="warning">WARNING: Pay attention to your real-world surroundings while playing!</div>
    <div id="controls">
        <button id="recenterBtn">Recenter View</button>
    </div>

    <script>
        // --- Configuration ---
        const GAME_AREA_WIDTH_FEET = 50;
        const GAME_AREA_HEIGHT_FEET = 50;
        const FEET_TO_METERS = 0.3048;
        const GAME_AREA_WIDTH_METERS = GAME_AREA_WIDTH_FEET * FEET_TO_METERS;
        const GAME_AREA_HEIGHT_METERS = GAME_AREA_HEIGHT_FEET * FEET_TO_METERS;
        const PACMAN_RADIUS = 15; // pixels
        const GHOST_RADIUS = 14; // pixels
        const GHOST_SPEED = 0.3; // meters per second (relative to game time)
        const NUM_GHOSTS = 4;
        const GPS_OPTIONS = {
            enableHighAccuracy: true,
            maximumAge: 5000, // Use cache if data is not older than 5 seconds
            timeout: 10000 // Give up after 10 seconds
        };

        // --- Global Variables ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statusElement = document.getElementById('status');
        const recenterBtn = document.getElementById('recenterBtn');

        let canvasWidth = window.innerWidth;
        let canvasHeight = window.innerHeight;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        let initialLat = null;
        let initialLon = null;
        let currentLat = null;
        let currentLon = null;

        // View offset allows panning the view if PacMan goes near edge
        let viewOffsetX = 0;
        let viewOffsetY = 0;
        let targetViewOffsetX = 0;
        let targetViewOffsetY = 0;

        // Pacman's position in METERS relative to start
        let pacmanX_meters = 0;
        let pacmanY_meters = 0;

        // Scaling factor: pixels per meter
        let pixelsPerMeterX = canvasWidth / GAME_AREA_WIDTH_METERS;
        let pixelsPerMeterY = canvasHeight / GAME_AREA_HEIGHT_METERS;
        // Use a single scale factor to avoid distortion
        let pixelsPerMeter = Math.min(pixelsPerMeterX, pixelsPerMeterY);


        let ghosts = [];
        let isGameOver = false;
        let gameStarted = false;
        let lastTimestamp = 0;
        let mouthAngle = 0;
        let mouthOpening = true;

        // --- Helper Functions ---

        function degreesToRadians(degrees) {
            return degrees * Math.PI / 180;
        }

        // Haversine formula to calculate distance between two lat/lon points in meters
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // Earth radius in meters
            const phi1 = degreesToRadians(lat1);
            const phi2 = degreesToRadians(lat2);
            const deltaPhi = degreesToRadians(lat2 - lat1);
            const deltaLambda = degreesToRadians(lon2 - lon1);

            const a = Math.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) +
                      Math.cos(phi1) * Math.cos(phi2) *
                      Math.sin(deltaLambda / 2) * Math.sin(deltaLambda / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c;
        }

        // Calculate signed displacement in meters
        function calculateDisplacement(startLat, startLon, currentLat, currentLon) {
            const N_S_dist = calculateDistance(startLat, startLon, currentLat, startLon);
            const E_W_dist = calculateDistance(startLat, startLon, startLat, currentLon);

            // Determine sign based on direction
            const deltaY_meters = (currentLat > startLat) ? N_S_dist : -N_S_dist; // North is positive Y
            const deltaX_meters = (currentLon > startLon) ? E_W_dist : -E_W_dist; // East is positive X

            return { x: deltaX_meters, y: deltaY_meters };
        }

        // Convert game world meters to canvas coordinates
        function metersToCanvas(metersX, metersY) {
             // Center the view on the canvas, adjust by view offset
            const canvasX = canvasWidth / 2 + (metersX - viewOffsetX) * pixelsPerMeter;
            const canvasY = canvasHeight / 2 - (metersY - viewOffsetY) * pixelsPerMeter; // Y is inverted on canvas
            return { x: canvasX, y: canvasY };
        }

        function drawPacman(canvasX, canvasY) {
            // Animate mouth
            const baseAngle = Math.PI / 8; // 22.5 degrees
            if (mouthOpening) {
                mouthAngle += 0.05;
                if (mouthAngle >= baseAngle) mouthOpening = false;
            } else {
                mouthAngle -= 0.05;
                if (mouthAngle <= 0) mouthOpening = true;
            }

            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            ctx.arc(canvasX, canvasY, PACMAN_RADIUS, mouthAngle, Math.PI * 2 - mouthAngle);
            ctx.lineTo(canvasX, canvasY); // Complete the pie shape
            ctx.closePath();
            ctx.fill();
        }

        function drawGhost(ghost, color) {
            const { x: canvasX, y: canvasY } = metersToCanvas(ghost.x, ghost.y);
            const radius = GHOST_RADIUS;
            const feet = radius * 0.4; // Wavy feet height

            ctx.fillStyle = color;
            ctx.beginPath();
            // Head
            ctx.arc(canvasX, canvasY, radius, Math.PI, 0);
            // Body base
            ctx.lineTo(canvasX + radius, canvasY + radius);
            // Feet (simple wavy line)
            ctx.lineTo(canvasX + radius * 0.66, canvasY + radius - feet);
            ctx.lineTo(canvasX + radius * 0.33, canvasY + radius);
            ctx.lineTo(canvasX, canvasY + radius - feet);
            ctx.lineTo(canvasX - radius * 0.33, canvasY + radius);
            ctx.lineTo(canvasX - radius * 0.66, canvasY + radius - feet);
            ctx.lineTo(canvasX - radius, canvasY + radius);
            ctx.closePath();
            ctx.fill();

            // Eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(canvasX - radius * 0.4, canvasY - radius * 0.2, radius * 0.25, 0, Math.PI * 2); // Left eye white
            ctx.arc(canvasX + radius * 0.4, canvasY - radius * 0.2, radius * 0.25, 0, Math.PI * 2); // Right eye white
            ctx.fill();
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(canvasX - radius * 0.4, canvasY - radius * 0.2, radius * 0.1, 0, Math.PI * 2); // Left pupil
            ctx.arc(canvasX + radius * 0.4, canvasY - radius * 0.2, radius * 0.1, 0, Math.PI * 2); // Right pupil
            ctx.fill();
        }

        function updateGhosts(deltaTime) {
            const ghostColors = ['red', 'pink', 'cyan', 'orange'];
            ghosts.forEach((ghost, index) => {
                // Simple AI: Move towards Pac-Man, but with some inertia/randomness
                const dx = pacmanX_meters - ghost.x;
                const dy = pacmanY_meters - ghost.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                let moveX = 0;
                let moveY = 0;

                if (dist > 1) { // Don't divide by zero if right on top
                    // Normalized direction vector
                    const dirX = dx / dist;
                    const dirY = dy / dist;
                    moveX = dirX * GHOST_SPEED * deltaTime;
                    moveY = dirY * GHOST_SPEED * deltaTime;
                }

                 // Add some random wobble? (Optional)
                 // moveX += (Math.random() - 0.5) * 0.1 * GHOST_SPEED * deltaTime;
                 // moveY += (Math.random() - 0.5) * 0.1 * GHOST_SPEED * deltaTime;

                ghost.x += moveX;
                ghost.y += moveY;

                // Keep ghosts within bounds (optional, maybe let them wander slightly?)
                const halfWidth = GAME_AREA_WIDTH_METERS / 2;
                const halfHeight = GAME_AREA_HEIGHT_METERS / 2;
                ghost.x = Math.max(-halfWidth, Math.min(halfWidth, ghost.x));
                ghost.y = Math.max(-halfHeight, Math.min(halfHeight, ghost.y));
            });
        }

        function checkCollisions() {
            ghosts.forEach(ghost => {
                const dx = pacmanX_meters - ghost.x;
                const dy = pacmanY_meters - ghost.y;
                const distance_meters = Math.sqrt(dx * dx + dy * dy);

                // Convert radii to meters for collision check
                const pacmanRadiusMeters = PACMAN_RADIUS / pixelsPerMeter;
                const ghostRadiusMeters = GHOST_RADIUS / pixelsPerMeter;

                if (distance_meters < pacmanRadiusMeters + ghostRadiusMeters) {
                    isGameOver = true;
                }
            });
        }

        function initGhosts() {
             const halfWidth = GAME_AREA_WIDTH_METERS / 2;
             const halfHeight = GAME_AREA_HEIGHT_METERS / 2;
             for (let i = 0; i < NUM_GHOSTS; i++) {
                 ghosts.push({
                    // Start near corners or center, away from PacMan's start (0,0)
                    x: (Math.random() > 0.5 ? 1 : -1) * halfWidth * 0.7 * Math.random(),
                    y: (Math.random() > 0.5 ? 1 : -1) * halfHeight * 0.7 * Math.random(),
                 });
             }
        }

        function recenterView() {
             // Set the target offset to Pac-Man's current position
             targetViewOffsetX = pacmanX_meters;
             targetViewOffsetY = pacmanY_meters;
             statusElement.textContent = "View recentered!";
             setTimeout(() => updateStatus(), 2000); // Clear message after 2s
        }

        // --- GPS Handling ---

        function handleInitialPosition(position) {
            initialLat = position.coords.latitude;
            initialLon = position.coords.longitude;
            currentLat = initialLat;
            currentLon = initialLon;

            statusElement.textContent = "GPS Locked! Walk around to move Pac-Man.";
            console.log("Initial Position:", initialLat, initialLon);

            initGhosts();
            gameStarted = true;
            lastTimestamp = performance.now();
            gameLoop(); // Start the game loop only after getting initial position

            // Start watching for subsequent position updates
            navigator.geolocation.watchPosition(handlePositionUpdate, handleError, GPS_OPTIONS);

            // Add listener for recenter button
            recenterBtn.addEventListener('click', recenterView);
        }

        function handlePositionUpdate(position) {
            if (!initialLat || isGameOver) return; // Don't update if game hasn't started or is over

            currentLat = position.coords.latitude;
            currentLon = position.coords.longitude;
            const accuracy = position.coords.accuracy; // Accuracy in meters

            // Calculate displacement from the starting point
            const displacement = calculateDisplacement(initialLat, initialLon, currentLat, currentLon);

            pacmanX_meters = displacement.x;
            pacmanY_meters = displacement.y;

             // Optional: Keep Pac-Man within the defined game area bounds
             const halfWidth = GAME_AREA_WIDTH_METERS / 2;
             const halfHeight = GAME_AREA_HEIGHT_METERS / 2;
             pacmanX_meters = Math.max(-halfWidth, Math.min(halfWidth, pacmanX_meters));
             pacmanY_meters = Math.max(-halfHeight, Math.min(halfHeight, pacmanY_meters));

             // Update view offset smoothly if PacMan gets close to the edge
             const edgeThresholdX = canvasWidth * 0.3; // 30% from edge
             const edgeThresholdY = canvasHeight * 0.3;
             const { x: pacmanCanvasX, y: pacmanCanvasY } = metersToCanvas(pacmanX_meters, pacmanY_meters);

             if (pacmanCanvasX < edgeThresholdX) {
                 targetViewOffsetX -= (edgeThresholdX - pacmanCanvasX) / pixelsPerMeter * 0.1; // Move view left
             } else if (pacmanCanvasX > canvasWidth - edgeThresholdX) {
                 targetViewOffsetX += (pacmanCanvasX - (canvasWidth - edgeThresholdX)) / pixelsPerMeter * 0.1; // Move view right
             }
             if (pacmanCanvasY < edgeThresholdY) {
                 targetViewOffsetY += (edgeThresholdY - pacmanCanvasY) / pixelsPerMeter * 0.1; // Move view up (decrease Y offset)
             } else if (pacmanCanvasY > canvasHeight - edgeThresholdY) {
                 targetViewOffsetY -= (pacmanCanvasY - (canvasHeight - edgeThresholdY)) / pixelsPerMeter * 0.1; // Move view down (increase Y offset)
             }


            updateStatus(accuracy); // Update status with accuracy
            // console.log("Position Update:", currentLat, currentLon, "-> Meters:", pacmanX_meters, pacmanY_meters);
        }

        function handleError(error) {
            console.error("GPS Error:", error);
            let message = "Error getting GPS location: ";
            switch (error.code) {
                case error.PERMISSION_DENIED:
                    message += "Permission denied.";
                    break;
                case error.POSITION_UNAVAILABLE:
                    message += "Location information is unavailable.";
                    break;
                case error.TIMEOUT:
                    message += "Location request timed out.";
                    break;
                case error.UNKNOWN_ERROR:
                    message += "An unknown error occurred.";
                    break;
            }
            statusElement.textContent = message;
            statusElement.style.color = 'red';
            isGameOver = true; // Stop game if GPS fails critically
        }

        function updateStatus(accuracy = null) {
            if (isGameOver) return;
            if (!gameStarted) {
                 statusElement.textContent = "Waiting for initial GPS Lock...";
                 return;
            }
            let statusText = `Lat: ${currentLat?.toFixed(5)}, Lon: ${currentLon?.toFixed(5)}`;
            if (accuracy !== null) {
                statusText += ` | Acc: ${accuracy.toFixed(1)}m`;
            }
            statusText += ` | Pos (m): ${pacmanX_meters.toFixed(1)}, ${pacmanY_meters.toFixed(1)}`;
            statusElement.textContent = statusText;
             statusElement.style.color = '#lime'; // Ensure it's green if showing data
        }


        // --- Game Loop ---

        function update(deltaTime) {
            if (isGameOver || !gameStarted) return;

            // Smoothly move view offset towards target
            viewOffsetX += (targetViewOffsetX - viewOffsetX) * 0.1;
            viewOffsetY += (targetViewOffsetY - viewOffsetY) * 0.1;

            updateGhosts(deltaTime);
            checkCollisions();
        }

        function drawGrid() {
            ctx.strokeStyle = 'rgba(0, 50, 100, 0.5)'; // Dark blue grid
            ctx.lineWidth = 1;
            const gridSizeMeters = 5; // Draw a line every 5 meters
            const gridSizePixels = gridSizeMeters * pixelsPerMeter;

            // Calculate the meter range currently visible
            const minMetersX = viewOffsetX - (canvasWidth / 2) / pixelsPerMeter;
            const maxMetersX = viewOffsetX + (canvasWidth / 2) / pixelsPerMeter;
            const minMetersY = viewOffsetY - (canvasHeight / 2) / pixelsPerMeter;
            const maxMetersY = viewOffsetY + (canvasHeight / 2) / pixelsPerMeter;

             // Find the starting grid lines just off-screen or at the edge
             const startGridX = Math.ceil(minMetersX / gridSizeMeters) * gridSizeMeters;
             const startGridY = Math.ceil(minMetersY / gridSizeMeters) * gridSizeMeters;

            // Vertical lines
            for (let mx = startGridX; mx <= maxMetersX; mx += gridSizeMeters) {
                const { x: canvasX } = metersToCanvas(mx, 0); // Y coord doesn't matter for vertical line pos
                ctx.beginPath();
                ctx.moveTo(canvasX, 0);
                ctx.lineTo(canvasX, canvasHeight);
                ctx.stroke();
            }
             // Horizontal lines
             for (let my = startGridY; my <= maxMetersY; my += gridSizeMeters) {
                const { y: canvasY } = metersToCanvas(0, my); // X coord doesn't matter for horizontal line pos
                ctx.beginPath();
                ctx.moveTo(0, canvasY);
                ctx.lineTo(canvasWidth, canvasY);
                ctx.stroke();
            }

            // Draw boundary box (optional visual aid)
            ctx.strokeStyle = 'rgba(100, 100, 255, 0.8)';
            ctx.lineWidth = 3;
            const halfWidthMeters = GAME_AREA_WIDTH_METERS / 2;
            const halfHeightMeters = GAME_AREA_HEIGHT_METERS / 2;
            const topLeft = metersToCanvas(-halfWidthMeters, halfHeightMeters);
            const bottomRight = metersToCanvas(halfWidthMeters, -halfHeightMeters);
            ctx.strokeRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);

        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            if (!gameStarted) {
                ctx.fillStyle = 'white';
                ctx.font = '20px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Waiting for GPS...', canvasWidth / 2, canvasHeight / 2);
                return;
            }

            drawGrid(); // Draw background grid

            // Draw Ghosts
            const ghostColors = ['red', 'pink', 'cyan', 'orange'];
            ghosts.forEach((ghost, index) => {
                drawGhost(ghost, ghostColors[index % ghostColors.length]);
            });

            // Draw Pac-Man at his calculated canvas position
            const { x: pacmanCanvasX, y: pacmanCanvasY } = metersToCanvas(pacmanX_meters, pacmanY_meters);
            drawPacman(pacmanCanvasX, pacmanCanvasY);


            // Draw Game Over Message
            if (isGameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, canvasHeight / 2 - 30, canvasWidth, 60);
                ctx.fillStyle = 'red';
                ctx.font = 'bold 30px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER!', canvasWidth / 2, canvasHeight / 2 + 10);
                 if (!initialLat) { // Specific message if GPS failed at start
                     ctx.font = '16px sans-serif';
                     ctx.fillText('Could not get initial GPS position.', canvasWidth / 2, canvasHeight / 2 + 40);
                 }
            }
        }

        function gameLoop(timestamp) {
            const deltaTime = (timestamp - lastTimestamp) / 1000; // Time elapsed in seconds
            lastTimestamp = timestamp;

            if (gameStarted && !isGameOver) {
                update(deltaTime);
            }
            draw();

            requestAnimationFrame(gameLoop);
        }

        // --- Initialization ---
        window.onload = () => {
             // Alert user about safety!
             alert("SAFETY WARNING:\nPlease be constantly aware of your real-world surroundings while playing. Do not focus solely on the screen. Watch out for obstacles, traffic, and other people!");

            // Adjust canvas size on resize
            window.addEventListener('resize', () => {
                canvasWidth = window.innerWidth;
                canvasHeight = window.innerHeight;
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                 // Recalculate scale - maintain aspect ratio if needed
                pixelsPerMeterX = canvasWidth / GAME_AREA_WIDTH_METERS;
                pixelsPerMeterY = canvasHeight / GAME_AREA_HEIGHT_METERS;
                pixelsPerMeter = Math.min(pixelsPerMeterX, pixelsPerMeterY);
                // No need to redraw immediately, game loop handles it
            });

            // Check for Geolocation support
            if ('geolocation' in navigator) {
                // Request initial position
                navigator.geolocation.getCurrentPosition(handleInitialPosition, handleError, GPS_OPTIONS);
            } else {
                statusElement.textContent = 'Geolocation is not supported by your browser.';
                statusElement.style.color = 'red';
                isGameOver = true; // Can't play without geolocation
                 draw(); // Draw the error state once
            }
        };

    </script>
</body>
</html>
