<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>GPS Pac-Man</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Basic styling for the body and canvas */
        body {
            font-family: 'Press Start 2P', cursive; /* Apply arcade font */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #000; /* Black background */
            color: #fff; /* White text */
            overflow: hidden; /* Prevent scrolling */
            touch-action: none; /* Disable panning/zooming on touch devices */
        }
        /* Style the game canvas */
        #gameCanvas {
            background-color: #111; /* Dark background for canvas */
            border: 4px solid #00ffff; /* Cyan border */
            display: block; /* Remove extra space below canvas */
            max-width: 95vw; /* Max width relative to viewport */
            max-height: 70vh; /* Max height relative to viewport */
            aspect-ratio: 1 / 1; /* Maintain square aspect ratio */
            box-shadow: 0 0 15px #00ffff; /* Glow effect */
            border-radius: 10px; /* Slightly rounded corners */
        }
        /* Style buttons with arcade look */
        button {
            font-family: 'Press Start 2P', cursive;
            background-color: #ffff00; /* Yellow background */
            color: #000; /* Black text */
            border: 3px solid #fff; /* White border */
            padding: 10px 20px;
            margin: 10px;
            cursor: pointer;
            border-radius: 8px; /* Rounded corners */
            box-shadow: 0 4px #888; /* Simple shadow */
            transition: all 0.1s ease;
            text-transform: uppercase;
        }
        button:active {
            box-shadow: 0 2px #555;
            transform: translateY(2px);
        }
        /* Style the message area */
        #message {
            margin-top: 15px;
            padding: 10px;
            min-height: 50px; /* Ensure space for potentially longer messages */
            text-align: center;
            color: #ffff00; /* Yellow text for messages */
            font-size: 0.9em; /* Slightly smaller font for messages */
            line-height: 1.4; /* Better line spacing */
        }
        /* Hide elements initially */
        .hidden {
            display: none;
        }
        /* Style for game over overlay */
        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            color: #ff0000; /* Red game over text */
            text-align: center;
        }
        /* Style for safety warning */
        #safetyWarning {
             margin-top: 15px;
             padding: 10px;
             color: #ffcc00; /* Orange warning color */
             text-align: center;
             font-size: 0.8em;
        }
    </style>
</head>
<body>

    <h1 class="text-2xl mb-4 text-yellow-400">GPS Pac-Man</h1>

    <div id="message">Press Start Game to begin!</div>

    <canvas id="gameCanvas" width="400" height="400"></canvas>

    <div class="mt-4">
        <button id="startButton">Start Game</button>
        <button id="resetOriginButton" class="hidden">Reset Origin</button>
    </div>

     <div id="safetyWarning" class="hidden">
        Warning: Pay attention to your real-world surroundings while playing!
    </div>

    <div id="gameOverScreen" class="hidden">
        <h2 class="text-4xl mb-4">Game Over!</h2>
        <button id="restartButton">Restart</button>
    </div>

    <script>
        // --- Game Configuration ---
        const GAME_AREA_METERS = 15.24; // Approx 50 feet
        const PACMAN_RADIUS = 10;
        const GHOST_RADIUS = 10;
        const GHOST_SPEED = 0.5; // Pixels per frame
        const NUM_GHOSTS = 4;
        const GHOST_COLORS = ['#FF0000', '#FFB8FF', '#00FFFF', '#FFB852']; // Red, Pink, Cyan, Orange

        // --- Canvas & Context ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let canvasSize = Math.min(canvas.width, canvas.height); // Use the smaller dimension

        // --- UI Elements ---
        const messageEl = document.getElementById('message');
        const startButton = document.getElementById('startButton');
        const resetOriginButton = document.getElementById('resetOriginButton');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const restartButton = document.getElementById('restartButton');
        const safetyWarning = document.getElementById('safetyWarning');

        // --- Game State ---
        let originCoords = null; // { latitude: number, longitude: number }
        let currentCoords = null; // { latitude: number, longitude: number }
        let watchId = null;
        let playerPos = { x: canvasSize / 2, y: canvasSize / 2 };
        let ghosts = [];
        let animationFrameId = null;
        let isGameOver = false;
        let metersPerPixel = GAME_AREA_METERS / canvasSize;
        let pacmanMouthOpen = true;
        let frameCount = 0; // For animation timing

        // --- GPS Options ---
        const gpsOptions = {
            enableHighAccuracy: true,
            timeout: 10000, // 10 seconds
            maximumAge: 0 // Don't use cached position
        };

        // --- Initialization ---
        function initGame() {
            console.log("Initializing game..."); // Debug log
            // Reset game state
            isGameOver = false;
            originCoords = null;
            currentCoords = null;
            ghosts = [];
            frameCount = 0;

            // Stop existing loops/watches
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
                console.log("GPS watch cleared.");
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                console.log("Animation frame cancelled.");
            }

            // Reset UI elements
            gameOverScreen.classList.add('hidden');
            startButton.classList.remove('hidden');
            resetOriginButton.classList.add('hidden');
            safetyWarning.classList.add('hidden');
            messageEl.textContent = 'Press Start Game to begin!';

            // Ensure canvas is sized correctly and draw initial state
            resizeCanvas(); // Call resize first
            playerPos = { x: canvasSize / 2, y: canvasSize / 2 }; // Reset player position after resize
            drawGameArea(); // Draw initial border
            drawPacman(playerPos.x, playerPos.y); // Draw Pacman centered
             console.log("Game initialized.");
        }

        // --- Event Listeners ---
        startButton.addEventListener('click', startGame);
        resetOriginButton.addEventListener('click', resetOrigin);
        restartButton.addEventListener('click', initGame); // Restart calls initGame
        window.addEventListener('resize', resizeCanvas); // Adjust canvas on resize

        // --- Canvas Resizing ---
        function resizeCanvas() {
            // Make canvas responsive, maintaining aspect ratio
            const availableWidth = window.innerWidth * 0.95;
            const availableHeight = window.innerHeight * 0.70;
            const size = Math.min(availableWidth, availableHeight);

            // Only update if size actually changes to avoid unnecessary redraws
            if (canvas.width !== size || canvas.height !== size) {
                canvas.width = size;
                canvas.height = size;
                canvasSize = size; // Update canvasSize variable
                metersPerPixel = GAME_AREA_METERS / canvasSize; // Recalculate scale
                console.log(`Canvas resized to: ${canvasSize}x${canvasSize}, m/px: ${metersPerPixel}`);

                // If game is running, redraw immediately and update positions if needed
                if (animationFrameId && !isGameOver) {
                     // Recalculate player position based on new canvas size and existing coords
                    if (currentCoords && originCoords) {
                        updatePlayerPosition(currentCoords); // Recalculate pixels from meters
                    } else {
                         // Center player if no coords yet (shouldn't happen if game is running)
                        playerPos = { x: canvasSize / 2, y: canvasSize / 2 };
                    }
                     // Reposition ghosts proportionally (optional, simple approach)
                     ghosts.forEach(ghost => {
                         // This is a basic repositioning, might need refinement
                         ghost.x = (ghost.x / (canvas.width / size)) * size;
                         ghost.y = (ghost.y / (canvas.height / size)) * size;
                     });
                    draw(); // Redraw with new dimensions
                } else if (!animationFrameId && !isGameOver) {
                    // If game hasn't started or is being initialized, redraw the static scene
                     playerPos = { x: canvasSize / 2, y: canvasSize / 2 }; // Keep player centered
                     drawGameArea();
                     drawPacman(playerPos.x, playerPos.y);
                }
            }
        }

        // --- Game Logic ---
        function startGame() {
            // ** Check for Secure Context (HTTPS) **
            if (!window.isSecureContext) {
                messageEl.innerHTML = 'Error: GPS requires a secure connection (HTTPS). Load this page via https://';
                console.warn("Geolocation API called from non-secure context.");
                // Optionally disable start button if not secure?
                // startButton.disabled = true;
                return;
            }

            if (!navigator.geolocation) {
                messageEl.textContent = 'Error: Geolocation is not supported by your browser.';
                return;
            }

            messageEl.textContent = 'Requesting GPS access...';
            startButton.classList.add('hidden');
            safetyWarning.classList.remove('hidden'); // Show safety warning

            // Get initial position to set origin
            console.log("Requesting current position...");
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    console.log("Initial position received:", position);
                    setOrigin(position);
                    messageEl.textContent = 'GPS acquired! Walk around to move Pac-Man.';
                    resetOriginButton.classList.remove('hidden');

                    // Start watching position
                    console.log("Starting GPS watch...");
                    watchId = navigator.geolocation.watchPosition(
                        handlePositionUpdate,
                        handleGpsError,
                        gpsOptions
                    );

                    // Initialize ghosts
                    createGhosts();

                    // Start the game loop
                    if (animationFrameId) cancelAnimationFrame(animationFrameId); // Clear previous loop if any
                    isGameOver = false;
                    console.log("Starting game loop...");
                    gameLoop();
                },
                (error) => {
                    // Error during initial getCurrentPosition
                    console.error("Error getting initial position:", error);
                    handleGpsError(error); // Use the common error handler
                    startButton.classList.remove('hidden'); // Show start button again on error
                    safetyWarning.classList.add('hidden');
                    resetOriginButton.classList.add('hidden'); // Ensure reset is hidden
                },
                gpsOptions
            );
        }

        function setOrigin(position) {
            originCoords = {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude
            };
            currentCoords = { ...originCoords }; // Start at origin
            playerPos = { x: canvasSize / 2, y: canvasSize / 2 }; // Center Pac-Man initially
            console.log('Origin set:', originCoords);
             messageEl.textContent = 'Origin set! Walk around.';
        }

        function resetOrigin() {
             messageEl.textContent = 'Attempting to reset origin...';
             // Always try to get a fresh position for resetting
             navigator.geolocation.getCurrentPosition(
                 (position) => {
                     console.log("Position received for reset:", position);
                     setOrigin(position); // Reuse setOrigin function
                     messageEl.textContent = 'Origin reset to current location.';
                 },
                 (error) => {
                     console.error("Error getting position for reset:", error);
                     handleGpsError(error); // Handle error
                     // Provide feedback that reset failed
                     messageEl.textContent = 'Failed to reset origin. ' + messageEl.textContent;
                 },
                 gpsOptions // Use same options
             );
        }


        function handlePositionUpdate(position) {
            // console.log("Position update received:", position); // Can be very noisy
            currentCoords = {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude
            };
            // Don't try to update position if origin hasn't been set yet or game over
            if (originCoords && !isGameOver) {
                updatePlayerPosition(currentCoords);
            }
             // Display accuracy for debugging/info - update less frequently?
             if (position.coords.accuracy && frameCount % 60 === 0) { // Update accuracy message once per second approx
                 // Keep the main message unless accuracy is poor
                 let accuracyMsg = `GPS Accuracy: ${position.coords.accuracy.toFixed(1)}m`;
                 if (messageEl.textContent.startsWith('Origin set') || messageEl.textContent.startsWith('GPS Accuracy')) {
                      messageEl.textContent = accuracyMsg;
                 }
             }
        }

        function updatePlayerPosition(newCoords) {
            if (!originCoords) return;

            const { deltaX_meters, deltaY_meters } = calculateDistanceMeters(
                newCoords.latitude,
                newCoords.longitude,
                originCoords.latitude,
                originCoords.longitude
            );

            // Convert meters difference to pixel difference
            const deltaX_pixels = deltaX_meters / metersPerPixel;
            const deltaY_pixels = -deltaY_meters / metersPerPixel; // Invert Y for canvas

            // Calculate new position relative to canvas center
            let newX = canvasSize / 2 + deltaX_pixels;
            let newY = canvasSize / 2 + deltaY_pixels;

            // Clamp position within canvas boundaries (with padding for Pac-Man's size)
            playerPos.x = Math.max(PACMAN_RADIUS, Math.min(canvasSize - PACMAN_RADIUS, newX));
            playerPos.y = Math.max(PACMAN_RADIUS, Math.min(canvasSize - PACMAN_RADIUS, newY));
        }

        function handleGpsError(error) {
            let msg = 'GPS Error: ';
            switch (error.code) {
                case error.PERMISSION_DENIED:
                    msg += 'Permission denied. Please check browser and OS settings (Settings > Privacy & Security > Location Services) and ensure HTTPS is used.';
                    break;
                case error.POSITION_UNAVAILABLE:
                    msg += 'Location unavailable. Check signal or device settings.';
                    break;
                case error.TIMEOUT:
                    msg += 'Request timed out. Try again.';
                    break;
                case error.UNKNOWN_ERROR:
                    msg += 'An unknown error occurred.';
                    break;
            }
            messageEl.textContent = msg;
            console.error("Detailed GPS Error:", error);

             // Stop game if running
             if (watchId) {
                 navigator.geolocation.clearWatch(watchId);
                 watchId = null;
             }
             if (animationFrameId) {
                 cancelAnimationFrame(animationFrameId);
                 animationFrameId = null;
                 // Maybe draw one last frame showing the error state?
                 // draw(); // Could be useful
             }
              // Reset UI to allow restarting
              startButton.classList.remove('hidden');
              resetOriginButton.classList.add('hidden');
              safetyWarning.classList.add('hidden');
              // Don't show game over screen for GPS errors
              gameOverScreen.classList.add('hidden');
        }

        // --- Distance Calculation ---
        function calculateDistanceMeters(lat1, lon1, lat2, lon2) {
            // Simple Equirectangular approximation - good enough for small distances
            const R = 6371e3; // Earth radius in meters
            const lat1Rad = lat1 * Math.PI / 180;
            const lat2Rad = lat2 * Math.PI / 180;
            const lon1Rad = lon1 * Math.PI / 180;
            const lon2Rad = lon2 * Math.PI / 180;

            const x = (lon2Rad - lon1Rad) * Math.cos((lat1Rad + lat2Rad) / 2);
            const y = (lat2Rad - lat1Rad);

            const deltaX_meters = R * x; // East-West difference
            const deltaY_meters = R * y; // North-South difference

            return { deltaX_meters, deltaY_meters };
        }

        // --- Ghost Logic ---
        function createGhosts() {
            ghosts = [];
             const padding = GHOST_RADIUS * 3; // Keep away from edge initially
             const quarterSize = canvasSize / 4; // Area to spawn in corners

            for (let i = 0; i < NUM_GHOSTS; i++) {
                let startX, startY;
                // Ensure ghosts don't spawn exactly on top of initial player pos
                const centerDistThreshold = canvasSize / 5;

                do {
                    switch(i % 4) {
                        case 0: // Top-left
                            startX = padding + Math.random() * quarterSize;
                            startY = padding + Math.random() * quarterSize;
                            break;
                        case 1: // Top-right
                            startX = canvasSize - padding - Math.random() * quarterSize;
                            startY = padding + Math.random() * quarterSize;
                            break;
                        case 2: // Bottom-left
                            startX = padding + Math.random() * quarterSize;
                            startY = canvasSize - padding - Math.random() * quarterSize;
                            break;
                        case 3: // Bottom-right
                            startX = canvasSize - padding - Math.random() * quarterSize;
                            startY = canvasSize - padding - Math.random() * quarterSize;
                            break;
                    }
                    // Check distance from center (initial player pos)
                    const dx = startX - canvasSize / 2;
                    const dy = startY - canvasSize / 2;
                    var distFromCenter = Math.sqrt(dx*dx + dy*dy);

                } while (distFromCenter < centerDistThreshold) // Re-roll if too close to center

                ghosts.push({
                    x: startX,
                    y: startY,
                    vx: (Math.random() - 0.5) * GHOST_SPEED * 2, // Random initial velocity
                    vy: (Math.random() - 0.5) * GHOST_SPEED * 2,
                    color: GHOST_COLORS[i % GHOST_COLORS.length]
                });
            }
             console.log("Ghosts created:", ghosts);
        }

        function updateGhosts() {
            ghosts.forEach(ghost => {
                // Move ghost
                ghost.x += ghost.vx;
                ghost.y += ghost.vy;

                // Bounce off walls - More robust clamping
                if (ghost.x - GHOST_RADIUS < 0) {
                    ghost.x = GHOST_RADIUS;
                    ghost.vx *= -1;
                } else if (ghost.x + GHOST_RADIUS > canvasSize) {
                    ghost.x = canvasSize - GHOST_RADIUS;
                    ghost.vx *= -1;
                }
                if (ghost.y - GHOST_RADIUS < 0) {
                    ghost.y = GHOST_RADIUS;
                    ghost.vy *= -1;
                } else if (ghost.y + GHOST_RADIUS > canvasSize) {
                    ghost.y = canvasSize - GHOST_RADIUS;
                    ghost.vy *= -1;
                }

                 // Optional: Add slight random change in direction occasionally
                 if (Math.random() < 0.01) { // 1% chance per frame
                     ghost.vx = (Math.random() - 0.5) * GHOST_SPEED * 2;
                     ghost.vy = (Math.random() - 0.5) * GHOST_SPEED * 2;
                 }
            });
        }

        // --- Collision Detection ---
        function checkCollisions() {
            if (isGameOver) return; // Don't check if already over

            ghosts.forEach(ghost => {
                const dx = playerPos.x - ghost.x;
                const dy = playerPos.y - ghost.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Use slightly smaller radius sum for collision to feel fairer
                if (distance < (PACMAN_RADIUS + GHOST_RADIUS) * 0.8) {
                    gameOver();
                }
            });
        }

        function gameOver() {
            if (isGameOver) return; // Prevent multiple triggers

            isGameOver = true;
            console.log("Game Over triggered.");
            messageEl.textContent = 'Game Over!'; // Set final message
            gameOverScreen.classList.remove('hidden'); // Show overlay
            resetOriginButton.classList.add('hidden'); // Hide reset button
            safetyWarning.classList.add('hidden'); // Hide warning

            // Stop GPS updates and game loop
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
                console.log("GPS watch cleared on game over.");
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                console.log("Animation frame cancelled on game over.");
            }
             // Optionally draw one last frame showing Pac-Man caught?
             draw();
        }


        // --- Drawing ---
        function drawGameArea() {
             // Clear background
             ctx.fillStyle = '#111';
             ctx.fillRect(0, 0, canvas.width, canvas.height);
             // Draw border
             ctx.strokeStyle = '#00ffff'; // Cyan border
             ctx.lineWidth = 4;
             ctx.strokeRect(0, 0, canvas.width, canvas.height); // Draw border rect
        }

        function drawPacman(x, y) {
            // Animate mouth opening and closing only if game is not over
            if (!isGameOver) {
                frameCount++;
                if (frameCount % 15 === 0) { // Change mouth state every 15 frames
                    pacmanMouthOpen = !pacmanMouthOpen;
                }
            } else {
                pacmanMouthOpen = false; // Keep mouth closed on game over
            }


            let startAngle, endAngle;
            if (pacmanMouthOpen && !isGameOver) {
                startAngle = 0.2 * Math.PI; // Open mouth
                endAngle = 1.8 * Math.PI;
            } else {
                startAngle = 0; // Closed mouth (full circle)
                endAngle = 2 * Math.PI;
            }

            ctx.beginPath();
            ctx.arc(x, y, PACMAN_RADIUS, startAngle, endAngle);
            if (pacmanMouthOpen && !isGameOver) {
                 ctx.lineTo(x, y); // Draw line to center only when mouth is open
            }
            ctx.closePath();
            ctx.fillStyle = 'yellow';
            ctx.fill();
        }

        function drawGhost(x, y, color) {
            const bodyHeight = GHOST_RADIUS * 1.2;
            const bodyWidth = GHOST_RADIUS * 1.8;
            ctx.fillStyle = color;

            // Body
            ctx.beginPath();
            ctx.rect(x - bodyWidth / 2, y - bodyHeight / 2 + GHOST_RADIUS * 0.2, bodyWidth, bodyHeight);
            ctx.fill();

            // Head (semicircle)
            ctx.beginPath();
            ctx.arc(x, y - bodyHeight / 2 + GHOST_RADIUS * 0.2, bodyWidth / 2, Math.PI, 0); // Top arc
            ctx.fill();

            // Eyes
            const eyeRadius = GHOST_RADIUS * 0.2;
            const eyeOffsetX = GHOST_RADIUS * 0.35;
            const eyeOffsetY = -GHOST_RADIUS * 0.1;
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(x - eyeOffsetX, y + eyeOffsetY, eyeRadius, 0, Math.PI * 2); // Left eye
            ctx.arc(x + eyeOffsetX, y + eyeOffsetY, eyeRadius, 0, Math.PI * 2); // Right eye
            ctx.fill();

             // Pupils
             const pupilRadius = GHOST_RADIUS * 0.1;
             ctx.fillStyle = 'black';
             ctx.beginPath();
             ctx.arc(x - eyeOffsetX, y + eyeOffsetY, pupilRadius, 0, Math.PI * 2); // Left pupil
             ctx.arc(x + eyeOffsetX, y + eyeOffsetY, pupilRadius, 0, Math.PI * 2); // Right pupil
             ctx.fill();
        }

        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw game area border
            drawGameArea();

            // Draw Ghosts
            ghosts.forEach(ghost => drawGhost(ghost.x, ghost.y, ghost.color));

            // Draw Pac-Man (only if position is known)
            if (playerPos) {
                 drawPacman(playerPos.x, playerPos.y);
            }

            // If game over, could add extra visual indication here if desired
            // e.g., darkening the screen slightly more, drawing 'X' on Pac-Man
        }

        // --- Game Loop ---
        function gameLoop() {
            if (isGameOver) return; // Should not be called if game over, but safe check

            // Update game state
            updateGhosts();
            // Player position is updated by GPS callback (handlePositionUpdate)

            // Check for collisions
            checkCollisions(); // This might set isGameOver

            // Draw everything
            draw();

            // Request next frame ONLY if game is not over
            if (!isGameOver) {
                animationFrameId = requestAnimationFrame(gameLoop);
            } else {
                 console.log("Game loop stopped due to game over.");
                 // Ensure the game over screen is definitely visible
                 gameOverScreen.classList.remove('hidden');
            }
        }

        // --- Initial Setup ---
        // Don't call resizeCanvas here, initGame will call it.
        initGame(); // Initialize game state but don't start GPS yet
        console.log("Initial setup complete. Waiting for Start button.");

    </script>

</body>
</html>

